#include "View.hpp"

// initializes sdl window
int View::window(const glimac::FilePath &applicationPath){
	GLenum glewInitError = glewInit();
	if(GLEW_OK != glewInitError){
		std::cerr << glewGetErrorString(glewInitError) << std::endl;
		return EXIT_FAILURE;
	}

	std::cout << "OpenGL Version : " << glGetString(GL_VERSION) << std::endl;
    std::cout << "GLEW Version : " << glewGetString(GLEW_VERSION) << std::endl;

    glimac::Program program = glimac::loadProgram(applicationPath.dirPath() + "shaders/triangle.vs.glsl", applicationPath.dirPath() + "shaders/triangle.fs.glsl");
    program.use();

    // _renderingEngine.push_back(RenderingInterface('s'));
    // for(int i = 0; i < this->_renderingEngine.size(); i++){
    // 	_renderingEngine[i].initialize();
    // }

GLuint vbo;
    glGenBuffers(1, &vbo);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    // => Tableau de sommets : un seul exemplaire de chaque sommet
    Vertex2DColor vertices[] = {
        Vertex2DColor(glm::vec2(-0.5, -0.5), glm::vec3(1, 0, 0)), // Sommet 0
        Vertex2DColor(glm::vec2(0.5, -0.5), glm::vec3(0, 1, 0)), // Sommet 1
        Vertex2DColor(glm::vec2(0.5, 0.5), glm::vec3(0, 0, 1)), // Sommet 2
        Vertex2DColor(glm::vec2(-0.5, 0.5), glm::vec3(1, 1, 1)) // Sommet 3
    };
    // => Penser à bien changer le nombre de sommet (4 au lieu de 6):
    glBufferData(GL_ARRAY_BUFFER, 4 * sizeof(Vertex2DColor), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // => Creation du IBO
    GLuint ibo;
    glGenBuffers(1, &ibo);

    // => On bind sur GL_ELEMENT_ARRAY_BUFFER, cible reservée pour les IBOs
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    // => Tableau d'indices: ce sont les indices des sommets à dessiner
    // On en a 6 afin de former deux triangles
    // Chaque indice correspond au sommet correspondant dans le VBO
    uint32_t indices[] = {
        0, 1, 2, 0, 2, 3
    };

    // => On remplit l'IBO avec les indices:
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(uint32_t), indices, GL_STATIC_DRAW);

    // => Comme d'habitude on debind avant de passer à autre chose
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    GLuint vao;
    glGenVertexArrays(1, &vao);

    glBindVertexArray(vao);

    // => On bind l'IBO sur GL_ELEMENT_ARRAY_BUFFER; puisqu'un VAO est actuellement bindé,
    // cela a pour effet d'enregistrer l'IBO dans le VAO
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    const GLuint VERTEX_ATTR_POSITION = 3;
    const GLuint VERTEX_ATTR_COLOR = 8;
    glEnableVertexAttribArray(VERTEX_ATTR_POSITION);
    glEnableVertexAttribArray(VERTEX_ATTR_COLOR);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glVertexAttribPointer(VERTEX_ATTR_POSITION, 2, GL_FLOAT, GL_FALSE, 
        sizeof(Vertex2DColor), (const GLvoid*) offsetof(Vertex2DColor, _position));
    glVertexAttribPointer(VERTEX_ATTR_COLOR, 3, GL_FLOAT, GL_FALSE, 
        sizeof(Vertex2DColor), (const GLvoid*) offsetof(Vertex2DColor, _color));
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    glBindVertexArray(0);    

    while(!this->_done){
    	SDL_Event e;
    	while(this->_windowManager.pollEvent(e)){
			this->manageEvents(e);
    	}
    	glClear(GL_COLOR_BUFFER_BIT);
		// for(int i = 0; i < this->_renderingEngine.size(); i++){
		// 	_renderingEngine[i].show();
		// }

 		glBindVertexArray(vao);

        // => On utilise glDrawElements à la place de glDrawArrays
        // Cela indique à OpenGL qu'il doit utiliser l'IBO enregistré dans le VAO
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

        glBindVertexArray(0);


    	this->_windowManager.swapBuffers();
    }

        glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);
    // for(int i = 0; i < this->_renderingEngine.size(); i++){
    // 	_renderingEngine[i].end();
    // }    
    return EXIT_SUCCESS;
}	

// deals with the events
void View::manageEvents(const SDL_Event &e){
	switch(e.type){
		case SDL_QUIT:
			this->_done = true;
			break;
		case SDL_KEYDOWN:
			this->_keyPressed = true;
			break;
		case SDL_KEYUP:
			this->manageKeyUpEvents(e.key.keysym.sym);
			break;
		case SDL_MOUSEBUTTONDOWN:
			std::cout << "zomm out" << std::endl;
			break;
		case SDL_MOUSEBUTTONUP:
			std::cout << "zoom int" << std::endl;
			break;
		case SDL_MOUSEMOTION:
			if(this->_cameraType == "first") this->firstPersonCameraMotion();
			else this->thirdPersonCameraMotion();
			break;
		default: 
			std::cout << "le sanglier court" << std::endl;
			break;
	}
	if(this->_keyPressed) this->manageKeyDownEvents(e.key.keysym.sym);
}

// converts mouse position from windowManager to position for game landmark
glm::vec2 View::getMousePosition(){
	float x = this->_windowManager.getMousePosition().x, y = this->_windowManager.getMousePosition().y;
	x = x - WINDOW_WIDTH / 2;
	y = -(y - WINDOW_HEIGHT * 2 / 3); 
	return glm::vec2(x, y);
}

// deals with key up events
void View::manageKeyUpEvents(const SDLKey &k){
	switch(k){
		case SDLK_DOWN:
			std::cout << "menu down !" << std::endl; 
			break;
		case SDLK_ESCAPE:
			this->_done = true;
			break;
		case SDLK_LEFT:
			std::cout << "menu left" << std::endl;
			break;
		case SDLK_RETURN:
			std::cout << "ok !" << std::endl;
			break;
		case SDLK_RIGHT:
			std::cout << "menu right" << std::endl;
			break;
		case SDLK_UP:
			std::cout << "menu up !" << std::endl;
			break;

		case SDLK_c:
			if(this->_cameraType == "third") this->_cameraType = "first";
			else this->_cameraType = "third";
			break;
		case SDLK_l:
			if(this->_locked) this->_locked = false;
			else this->_locked = true;
			break;
		case SDLK_d:
		case SDLK_q:
			this->_keyPressed = false;
			break;
		case SDLK_s:
			std::cout << "down !" << std::endl;
			break;
		case SDLK_z:
			std::cout << "jump !" << std::endl;
			break;
		default:
			break;
	}
}

// deals with key down events
void View::manageKeyDownEvents(const SDLKey &k){
	switch(k){
		case SDLK_d:
			std::cout << "droite !" << std::endl;
			break;
		case SDLK_q:
			std::cout << "gauche !" << std::endl;
			break;
		default:
			break;
	}	
}

//
void View::firstPersonCameraMotion(){

}
//
void View::thirdPersonCameraMotion(){

}